Hard regex:
(0x(((\d|[a-f])*\.(\d|[a-f])+)|((\d|[a-f])+\.?))(p(\+|\-)?(\d|[a-f])+)(f|l)?)|(((\d*\.\d+)|(\d+\.?))(e(\+|\-)?\d+)?(f|l)?)

Паттерн состоит из двух частей 
1) (((\d*\.\d+)|(\d+\.?))(e(\+|\-)?\d+)?(f|l)?)
Обычная часть, где можно указывать кол-во знаком в 10ой записи, с помощью "экспоненты", а так же писать в конце тип числа

2) (0x(((\d|[a-f])*\.(\d|[a-f])+)|((\d|[a-f])+\.?))(p(\+|\-)?(\d|[a-f])+)(f|l)?)
Для бинарных форматов.
Всё то же самое, только вместо цифр могут присутствовать ещё и буквы для 16ти ричной системы исчисления
А так же вместо буквы e должна присуствовать буква p.
Заметим, что с 17 стандарта во всех бинарных форматах p - обязано присутствовать.

Simple regex:
[+-]?([0-9]*[.])?[0-9]+

Примеры для проверки:
 1) 0.1e-1L
 2) 123.4e-5
 3) 0xa.bp10l
 4) 0x0.123p-1
 5) 231.523
 6) .1E4f
 

Standart of contract is here:
 https://en.cppreference.com/w/cpp/language/floating_literal 
 
 
 Полный пример:
 
#include <iostream>

int main() {
	
	std::cout << 123.456e-67 << ".1E4f"  << 58. << '\n' << 4e2 ;
			
	long kek0 = 123.4e-5-43.5+3;
	MyClass first1 = 1e10+1e-5L;
	double hello = 0x0.123p-1-0xa.bp10l;
	int gl13hg3 = 3.14+.1f-0.1e-1L;
	double a41a = 0x1ffp10-0X0p-1;
	double zegmond = 0x1.p0-0xf.p-1;
	clazz second2 = 1.-1.e-2;
        9.87654e-005
        0x0123 // NOT OK
        0x0123p0  // OK
	
	return 0;
}
